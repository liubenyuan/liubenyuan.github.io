<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta name="generator" content="jemdoc, see http://jemdoc.jaboc.net/" />
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="stylesheet" href="jemdoc.css" type="text/css" />
<title></title>
</head>
<body>
<table summary="Table for page layout." id="tlayout">
<tr valign="top">
<td id="layout-menu">
<div class="menu-item"><a href="index.html">Main</a></div>
<div class="menu-item"><a href="publications.html">Publications</a></div>
<div class="menu-category">Research</div>
<div class="menu-item"><a href="bsbl.html">BSBL</a></div>
<div class="menu-item"><a href="eit.html">EIT</a></div>
<div class="menu-category">Hacks</div>
<div class="menu-item"><a href="phealth.html" class="current">pHealth</a></div>
<div class="menu-item"><a href="radar.html">RADAR</a></div>
<div class="menu-item"><a href="nudtpaper.html">NUDTPaper</a></div>
<div class="menu-item"><a href="nrf51822.html">NRF51822</a></div>
</td>
<td id="layout-content">
<h1>Portable Healthcare : Hybrid Cardiography Monitoring via BLE</h1>
<p>Building a demo board to collect cardio-related bio-signals based on nrf51822-AK.</p>
<h2>pmodAD2 + Lx9micro + USB : building a 4-channel evaluation system</h2>
<p>先用中文夹杂英文做笔记 ：）</p>
<h3>pmodAD2</h3>
<p>pmodAD2, ad7991, I2C interface, up to 4 channels, 12-bit resolution. 要想使用vin4，需要disable REF_SEL，同时将JP1连接到vin4端口上。对于ad7991的操作通过I2C接口进行，主要配置哪几路AD用来转换（通过分时复用来实现多路ADC），是否使用外部参考电压，是否有bit trial或sample delay。<b>We may use this module with nrf51822 via the IIC bus</b>.</p>
<p>ad7991 remains in shutdown mode, powering up only for conversions. The conversion process is controlled by a command mode. The range (when REF_SEL disabled) is 0V to VDD.</p>
<p>ad7991的串口时钟速率fSCL划分为standard (100K), fast (400K), high speed (3.4M)三种, VDD典型范围在2.7V到5.5V。ad7991的地址为 0101000 (0101001)，注意地址是7位的哦，外带一位的R<i>W位：如果R</i>W=0，则对ad7991发起写操作；如果R/W=1，则对ad7991发起读操作。对配置地址写入配置数据即可完成ad7991的配置。配置字可参见器件手册 Table 10.</p>
<p>一个操作的要点是，在ad7991进行采样的过程中 (busy) ， I2C总线不要发起请求。ad7991的转化结果包含2B数据，其中最高两位为0，后续两位为对应的所转化的通道数，后续12位（不足的低位补零）则包含ADC结果。关键的步骤是：</p>
<ol>
<li><p>SDA pulled low, and wake up device</p>
</li>
<li><p>写配置地址和配置寄存器</p>
</li>
<li><p>写配置地址和读转化结果</p>
</li>
<li><p>根据通道数目确定master的ACK种类</p>
</li>
</ol>
<h3>Lx9micro</h3>
<p>为什么不学习一下Xilinx的SDK呢，让我们用一晚上rock一下microblaze吧 :)</p>
<div class="infoblock">
<div class="blockcontent">
<p>我们针对的是Xilinx的Spartan 6 Lx9 (XC6SLX9) micro开发板，需要用到cp210x uart to usb转接芯片以及Digilent的Jtag驱动。在Archlinux的wiki主页上（或者你可以Google搜索linux, digilent, lx9micro, Xilinx ISE），有关于在linux下，配置Xilinx ISE和Lx9micro的具体步骤。</p>
</div></div>
<p>Microblaze是一个Xilinx基于FPGA的硬核，主要使用Xilinx Platform Studio (XPS) Base System Builder (BSB) 进行开发. </p>
<div class="infoblock">
<div class="blockcontent">
<p>需要注意的是，我们需要下载Lx9micro对应的Xilinx Board Description (XBD)文件，这个文件可以从Avnet网站上下载到。具体到对于新制作的板子，我们应该怎样设计和编写这个文件，我们可以暂时放下。</p>
</div></div>
<p><b>第一课</b>, <a href="https://www.em.avnet.com/Support%20And%20Downloads/EDK01-Creating_Embedded_System_13_2_1.pdf">EDK01 - Creating Embedded System</a> 课程中讲解的很详细了，我们在这里重新温习一下里面的关键步骤和器件、软件。测试程序将置于LPDDR (一种mobile DDR) 中。步骤包括：</p>
<ol>
<li><p><b>Create the hardware platform</b>: 使用ISE添加一个embedded processor，通过BSB定制我们的硬件；在做这一步之前，我们需要下载Avnet的XBD文件（参见 <a href="https://www.em.avnet.com/Support%20And%20Downloads/avnet_edk14_3_xbd_files_9_11_2012_spartan.zip">EDK 14.3 XBD/IP-XACT Files</a>），按照步骤添加板级描述文件。(需要注意的是，在配置processor和peripheral时，我们没有添加CDCE913_I2C模块)。这一步骤会生成两个文件，一个是Microprocessor Hardware Specification (MHS)，用来配置总线以及外设等；另外一个是UCF文件，这一文件与VHDL工程中的用法一致。</p>
</li>
<li><p><b>Compiling the bitstream</b>: 添加UCF, Generate Top HDL Source，生成microblaze的bit文件，并且调出EDK界面；</p>
</li>
<li><p><b>Add Xilinx Application</b>: 生成一个peripheral的测试程序，这一步有现成的模板，生成后自动添加一个默认的BSP和默认的linker script；随后我们可以从EDK中将bit文件和Block Memory Map File (BMM)文件烧录到板子上。</p>
</li>
<li><p>配置run as，将STDIO重定向到ttyUSB0上，这样我们即可以在Console中看到运行结果，也可以通过EDK的Terminal连接来查看程序的运行结果。为了访问USB转串口，需要将你的用户添加到uucp以及lock组中，并且可以通过udev.rules修改ttyUSB0的默认属性（方法看这里 <a href="https://bbs.archlinux.org/viewtopic.php?id=86088">Permission to /dev/ttyUSB0</a>）。另外在ISE 14.3下，EDK会出现segfault，我们需要安装java-rxtx包，随后（参考 <a href="http://forums.xilinx.com/t5/Installation-and-Licensing/SDK-segfault-on-UART-output/td-p/160000">SDK segfault on UART output?</a>），创建simlink即可。</p>
</li>
</ol>
<p><b>第一课后续练习</b>，<a href="https://wiki.analog.com/resources/fpga/xilinx/pmod/ad7991">AD7991 PMOD XILINX FPGA REFERENCE DESIGN</a>. 发扬rapid  prototyping精神，我们直接研究一下AD7991模板的结构。</p>
<p>我们得到的reference design中有system.mhs system.xmp system.bsd data/system.ucf，在这些文件中，system.xmp是有ISE添加embedded processor自动生成的，而system.bsd是由xps (bsd)在配置MHS后编译得到的。我们首先：</p>
<ol>
<li><p>在ISE中添加embedded processor</p>
</li>
<li><p>然后启动一个空的XPS工程，将UCF文件和MHS文件<b>先后</b>复制到工程中。这里会弹出一个version manager更新我们的BSD。</p>
</li>
<li><p>随后我们退出XPS，在ISE中生成HDL。生成的新的MHS文件可以用diff查看与旧工程文件的区别。</p>
</li>
</ol>
<p>注意在dos编码格式下，我们可以用</p>
<div class="codeblock">
<div class="blockcontent"><pre>
:update
:set ff=unix
</pre></div></div>
<p>将refdesign中的编码更新一下，在diff之后，我们就看到仅仅是peripheral器件的版本号发生了改变。</p>
<p><tt>注意！</tt> 当我们采用microblaze的refdesign时，<tt>仅仅需要连接pmodAD2到3-6管脚上</tt>，而不能将8个管脚全部连接。这是因为在这个默认的refdesign中，7-12管脚是接地的。我们可以用extension cable来连接。</p>
<h3>ECG/PPG Frontend</h3>
<p>我们的ECG前端使用的是淘宝买到的ECG差分放大器，而PPG采用的是Pulsesensor一代的PPG采集玩具。<b>需要列出具体指标</b>。PPG的使用方法很简单，只要驱动上电源，其内置的信号放大器就可以实现采集。</p>
<h3>return to the FPGA/VHDL land</h3>
<p>最终精确的硬件实现我们还是使用VHDL，另外能否用内部存储器暂时将数据存储下来呢？</p>
<h2>添加一个PmodBT2</h2>
<p>我们准备添加一个pmodBT2模块，当前所有跳线都禁止。我们直接将pmodBT2的RX和TX，跟板子上CP2102的RX和TX直通，然后我们用一个蓝牙转USB的dongle，以及两个串口调试工具直连调试。</p>
<h3>第一步，直连PMODBT2到CP2102</h3>
<p>成功。<tt>但是</tt>，文档中说的RN42的串口开启了Hardware Flowcontrol，当我用minicom -s连接时，首先用Ctrl+A,E打开Echo，然后只有禁止了Hardware Flowcontrol，才能正确的进入命令模式。如输入三个dollar符号，显示CMD，等。</p>
<p>这一直显模式表示着pmodBT2模块已经顺利的和电脑通过USB2UART对接成功！</p>
<h3>第二步，主机搜索到RN42 Slave</h3>
<p>首先，我们要启动蓝牙设备</p>
<div class="codeblock">
<div class="blockcontent"><pre>
$ rfkill list
$ pacman -Q | grep blue
$ systemctl status bluetooth.service
</pre></div></div>
<p>要是<tt>bluetooth.service</tt>没开启，要记得enable。然后，看看我们的蓝牙是</p>
<div class="codeblock">
<div class="blockcontent"><pre>
$ lsusb
Bus 003 Device 005: ID 0a5c:21e6 Broadcom Corp. BCM20702 Bluetooth 4.0 [ThinkPad]
Bus 001 Device 017: ID 0a12:0001 Cambridge Silicon Radio, Ltd Bluetooth Dongle (HCI mode)
</pre></div></div>
<p>注意到x230上原声的蓝牙是hci1，而我们新买的dongle是hci0后，我们用</p>
<div class="codeblock">
<div class="blockcontent"><pre>
$ sudo hciconfig hci0 up
$ sudo hcitool scan
Scanning ...
    00:06:66:43:0F:2E   RN42-0F2E
</pre></div></div>
<p>就能找到我们的设备了，前面有MAC地址和设备ID。下一步就是配对儿啦。</p>
<h3>第三步，我们将蓝牙设备当作UART串口设备</h3>
<p>这里需要用到rfcomm工具</p>
<div class="codeblock">
<div class="blockcontent"><pre>
$ sudo modprobe btusb
$ sudo modprobe ath3k
$ sudo modprobe rfcomm
$ sudo rfcomm bind rfcomm0 00:06:66:43:0F:2E
</pre></div></div>
<p>然后我们的设备就成了一个串口哦</p>
<p>分别打开两个终端，一个连接<tt>/dev/ttyUSB0</tt>，一个连接<tt>/dev/rfcomm0</tt>即可。需要注意的是，两边的设置都为115200 8N1。在这种通信中，我发现无论两边开启hardware flowcontrol与否，都不影响两者的通信。记得要在minicom中开启Ctrl+A,E回显哦！</p>
<div id="footer">
<div id="footer-text">
Page generated 2014-03-10 21:00:12 UTC, by <a href="http://jemdoc.jaboc.net/">jemdoc</a>.
</div>
</div>
</td>
</tr>
</table>
</body>
</html>
