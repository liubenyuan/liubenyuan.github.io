# jemdoc: menu{MENU}{udpip.html}, nofooter

= UDP\/IP -- VHDL based MAC layer and transport protocol

We interface phy device with FPGA. On Lx9 microboard, a +DP83848J+ phy is used, while on Nexys3, a +LAN8710A+ is used. Both Phy device support standard MII\/RMII interface.

I recently (*2014-07-05*) purchased a nexys4 board, where it ships a +LAN8720A+ phy, which supports only RMII interface.

== strap pins

Configuration straps are latched upon Power-On reset (POR) or pin reset (nRST).

=== DP83848J

MII mode configuration of DP83848J, via power up boot mode (*PU* for pullup, *PD* for pulldown, by default, RX\_DV is internally weakly *pulled down*, the default value of *RX\_DV is 0*),
~~~
{}{table}{Configuration of DP83848}
*RX\_DV* (pin 39, MII\_MODE) | MAC Interface ||
PD (0) | MII Mode ||
PU (1) | RMII Mode
~~~

PHYAD\[4:0\] are,
~~~
{}{table}{PHY ADDRESS}
 ADDRESS BIT | *PIN* | *default* ||
 PHYAD\[0\] | COL | connect to FPGA ||
 PHYAD\[1\] | RXD0 | connect ||
 PHYAD\[2\] | RXD1 | connect ||
 PHYAD\[3\] | RXD2 | connect ||
 PHYAD\[4\] | RXD3 | connect
~~~

About the PHY\_ADDRESS. PHYAD4-PHYAD1 is internally *pulled down*, PHYAD0 is internally weakly *pulled up*, the PHY\_ADDRESS is by default +b"00001"+; if *bitgen* let's unused pins COL/PHYAD0 pulled down, and PHYAD4-PHYAD1 pulled-up as specified in ucf, the PHY\_ADDRESS will be altered as +b"11110"+. PHY\_ADDRESS +b"00000"+ is not allowed.

=== LAN8710A

PHYAD\[2:0\] are showed below. LAN8710 uses a SMI interface, where ADDRESS are configured via PHYAD\[2:0\]. These address are latched into an internal register at the end of hardware reset (default +b"000"+ ).
~~~
{}{table}{PHY Address}
 ADDRESS BIT | *PIN* | *default* ||
 PHYAD\[0\] | RXER | external PD(0) ||
 PHYAD\[1\] | RXCLK | external PD(0) ||
 PHYAD\[2\] | RXD3 | external PD(0)
~~~

MODE\[2:0\] bits controls the working mode of phy. Default is +b"100"+ (you need to pull-up COL in FPGA), works in /100Base-TX Half Duplex is advertised. Auto-negotiation enabled. CRS is active during Transmit & Receive./

~~~
{}{table}{MODE Address}
 ADDRESS BIT | *PIN* | *default* ||
 MODE\[0\] | RXD0 | external PD(0) ||
 MODE\[1\] | RXD1 | external PD(0) ||
 MODE\[2\] | COL | connect via 10$\Omega$ to FPGA
~~~

RMIISEL pins (*RXD2*) controls the working mode, with +PD (0)+ works in MII mode, +PU (1)+ in RMII mode. Default is PD(0) in +MII+ mode.
~~~
{}{table}{MODE Address}
 ADDRESS BIT | *PIN* | *default* ||
 RMIISEL | RXD2 | external PD(0)
~~~

Some nots on CRS (Carrier Sense) and COL (Collision Detect).
. +CRS:+ The device asserts CRS
based only on receive activity whenever the transceiver is either in repeater mode or full-duplex mode.
Otherwise the transceiver asserts CRS based on either transmit or receive activity.
. +COL:+ A collision is the occurrence of simultaneous transmit and receive operations. The COL output is
asserted to indicate that a collision has been detected. COL remains active for the duration of the
collision. COL is changed asynchronously to both RXCLK and TXCLK. The COL output becomes
inactive during full duplex mode.

== downlink -- receive data from PC and send back via UART interface

== uplink -- receive data from uart and send to PC via ethernet

== High-speed full duplex data logging from FPGA to PC

Most of the time, we collected large amount of data using FPGA and on-chip ADCs, and want sent them direct to PC. Only standard peripherals can be used. Some protocols may bump to our mind, for example, Bluetooth 2.1 (BLE is too slow for data logging), RS232 (where most of the time, we will use CP2102 to convert a serial interface to USB, and utilize the ttyUSBx on PC), wifi and ethernet. Among all these options, UART is the best. It is simple, utilize little FPGA on-chip resources, and the data can be logged in raw format. Most important, I had success with this protocol.

Transparent data transfer using RS232 via bluetooth or wifi, or even ethernet are now available. However, we had this problem : how could we transfer data from FPGA to PC, in high-speed, long-distance, and best of all, with little or no dirty work on excessive complex state machines?

= Ethernet playground

== play with the hardware using +ip+

We may control the interface via +ip+ under my archlinux,
~~~
{}{bash}
$ ip list
3: enp0s25: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 50
    link/ether 3c:97:0e:9e:b8:34 brd ff:ff:ff:ff:ff:ff
~~~

we bring this interface up and manually assign ip address +192.168.1.10+ and mask +255.255.255.0+ (24bit 1s) to it,
~~~
{}{bash}
$ sudo ip link set enp0s25 up
3: enp0s25: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc pfifo_fast state DOWN mode DEFAULT group default qlen 50
    link/ether 3c:97:0e:9e:b8:34 brd ff:ff:ff:ff:ff:ff
$ sudo ip addr add 192.168.1.10/24 dev enp0s25
$ sudo sysctl -w net.ipv4.tcp_window_scaling=0
$ sudo sysctl -w net.ipv4.tcp_timestamps=0
~~~

now we have,
~~~
{}{bash}
3: enp0s25: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc pfifo_fast state DOWN group default qlen 50
    link/ether 3c:97:0e:9e:b8:34 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.10/24 scope global enp0s25
       valid_lft forever preferred_lft forever
~~~
where all the information can be viewed in +wireshark+.

== understand the packets (or /shells/) of OSI-7 layer

A sample packet (phy--ip--udp),
~~~
{}{table}{ethernet structure}
                   | 1B | 2B | 3B | 4B | *Note* ||
Ethernet preamble  | 55 | 55 | 55 | 55 | generated by the chipset ||
                   | 55 | 55 | 55 | D5 | ||
Ethernet MAC (dst) | 01 | 02 | 03 | 04 | src=*01-02-03-04-05-06* ||
             (src) | 05 | 06 | 11 | 12 | dst=*11-12-13-14-15-16* ||
                   | 13 | 14 | 15 | 16 | ||
                   | 08 | 00 |    |    | type=IP ||
IP Header          | 45 | 00 | 00 | +2A+ | \#IP=*42B* (0x2A) ||
                   | 00 | 00 | 40 | 00 | ||
                   | 10 | +11+ |  |    | type=UDP ||
+IP CRC+           |    |    | CC | 9E | sum-add-inv ||
IP (src)           | 01 | 23 | 45 | 67 | ||
IP (dst)           | 89 | AB | CD | EF | ||
UDP (src\/dst)     | 00 | 17 | 17 | 17 | ||
UDP length         | 00 | +16+ |    |    | \#UDP=*22B* (0x16) ||
+UDP CRC+          |    |    | CB | 75 | sum-add-inv ||
UDP payload        | 48 | 65 | 6C | 6C | hell ||
                   | 6F | 20 | 77 | 6F | o,wo ||
                   | 72 | 6C | 64 | 21 | rld! ||
                   | 0D | 0A |    |    | \\\\n\\\\r ||
UDP padding        | 00 | 00 | 00 | 00 | pad for *46B* minimum ||
+Ethernet CRC+     | 52 | 5D | A4 | CF | CRC-32
~~~

On the physical wire, bits are transmitted LSB first (bit reversed) in Byte order. For example, *0xD5* is transmitted as *0x5, 0xD* in MII interface and *1010, 1011* on the wire.

. Ethernet CRC is calculate from Ethernet MAC to the last quad-byte (i.e., at the end of UDP padding) of data, use +CRC-32+. Padding is needed to ensure the total ethernet payload is in *46B\~1500B*.
. IP CRC is calculate on IP Header only. *A very intuitive example*, see [http://en.wikipedia.org/wiki/IPv4_header_checksum IPv4 header checksum] !! Which is simply +sum+, +add carry+, and +bit-wise inverse+.
. UDP CRC is calculate on pseudo UDP\/IP header. *A very intuitive example*, see [http://en.wikipedia.org/wiki/User_Datagram_Protocol UDP pseudo header checksum] !! It forms a pseudo header by encapsulating IP src, dst, +0x0011+ and UDP length, where the udp length is used twice and it stands for the total length of UDP header and data.

Data receive and transmite are simply +decap+ and +encap+ of the packets.

=== decap

=== encap

== play with the swiss-knife +wireshark+

= GUI frontend

We are going to use +Qt+ as the GUI frontend.

= Microblaze

为什么不学习一下Xilinx的SDK呢，让我们用一晚上rock一下microblaze吧 :)

~~~
我们针对的是Xilinx的Spartan 6 Lx9 (XC6SLX9) micro开发板，需要用到cp210x uart to usb转接芯片以及Digilent的Jtag驱动。在Archlinux的wiki主页上（或者你可以Google搜索linux, digilent, lx9micro, Xilinx ISE），有关于在linux下，配置Xilinx ISE和Lx9micro的具体步骤。

简而言之，就是
. 安装+adept-runtime+, 安装+digilent-plugin+，安装+adept-utilities+；
. 安装一些archlinux需要的+usbdrv+以及+fxload+，需要配置好*udev.rules*。添加用户到+uucp+；
. 最后，安装digilent plugin到ISE的+plugins+目录；
~~~

Microblaze是一个Xilinx基于FPGA的硬核，主要使用Xilinx Platform Studio (XPS) Base System Builder (BSB) 进行开发. 

~~~
需要注意的是，我们需要下载Lx9micro对应的Xilinx Board Description (XBD)文件，这个文件可以从Avnet网站上下载到。具体到对于新制作的板子，我们应该怎样设计和编写这个文件，我们可以暂时放下。
~~~

*第一课*, [https://www.em.avnet.com/Support%20And%20Downloads/EDK01-Creating_Embedded_System_13_2_1.pdf EDK01 - Creating Embedded System] 课程中讲解的很详细了，我们在这里重新温习一下里面的关键步骤和器件、软件。测试程序将置于LPDDR (一种mobile DDR) 中。步骤包括：
. *Create the hardware platform*: 使用ISE添加一个embedded processor，通过BSB定制我们的硬件；在做这一步之前，我们需要下载Avnet的XBD文件（参见 [https://www.em.avnet.com/Support%20And%20Downloads/avnet_edk14_3_xbd_files_9_11_2012_spartan.zip EDK 14.3 XBD\/IP-XACT Files]），按照步骤添加板级描述文件。(需要注意的是，在配置processor和peripheral时，我们没有添加CDCE913_I2C模块)。这一步骤会生成两个文件，一个是Microprocessor Hardware Specification (MHS)，用来配置总线以及外设等；另外一个是UCF文件，这一文件与VHDL工程中的用法一致。
. *Compiling the bitstream*: 添加UCF, Generate Top HDL Source，生成microblaze的bit文件，并且调出EDK界面；
. *Add Xilinx Application*: 生成一个peripheral的测试程序，这一步有现成的模板，生成后自动添加一个默认的BSP和默认的linker script；随后我们可以从EDK中将bit文件和Block Memory Map File (BMM)文件烧录到板子上。
. 配置run as，将STDIO重定向到ttyUSB0上，这样我们即可以在Console中看到运行结果，也可以通过EDK的Terminal连接来查看程序的运行结果。为了访问USB转串口，需要将你的用户添加到uucp以及lock组中，并且可以通过udev.rules修改ttyUSB0的默认属性（方法看这里 [https://bbs.archlinux.org/viewtopic.php?id=86088 Permission to \/dev\/ttyUSB0]）。另外在ISE 14.3下，EDK会出现segfault，我们需要安装java-rxtx包，随后（参考 [http://forums.xilinx.com/t5/Installation-and-Licensing/SDK-segfault-on-UART-output/td-p/160000 SDK segfault on UART output?]），创建simlink即可。

*第一课后续练习*，[https://wiki.analog.com/resources/fpga/xilinx/pmod/ad7991 AD7991 PMOD XILINX FPGA REFERENCE DESIGN]. 发扬rapid  prototyping精神，我们直接研究一下AD7991模板的结构。

我们得到的reference design中有system.mhs system.xmp system.bsd data\/system.ucf，在这些文件中，system.xmp是有ISE添加embedded processor自动生成的，而system.bsd是由xps (bsd)在配置MHS后编译得到的。我们首先：
. 在ISE中添加embedded processor
. 然后启动一个空的XPS工程，将UCF文件和MHS文件*先后*复制到工程中。这里会弹出一个version manager更新我们的BSD。
. 随后我们退出XPS，在ISE中生成HDL。生成的新的MHS文件可以用diff查看与旧工程文件的区别。

注意在dos编码格式下，我们可以用
~~~
update
set ff=unix
~~~
将refdesign中的编码更新一下，在diff之后，我们就看到仅仅是peripheral器件的版本号发生了改变。

*注意！* 当我们采用microblaze的refdesign时，*仅仅需要连接pmodAD2到3-6管脚上*，而不能将8个管脚全部连接。这是因为在这个默认的refdesign中，7-12管脚是接地的。我们可以用extension cable来连接。

== Ethernet

The commercial IP core (Xilinx Tri-MAC) is a complete implementation of a MAC layer. The lx9 microboard has an National Semiconductor DP83848J Phy layer and Tyco RJ45 connector. I found designs which directly use the LVDS pins on FPGA to implement the 10BASE-T protocol (MAC \+ PHY all in FPGA):

  . [http://www.punk.co.nz/2013/03/07/crafting-a-basic-ethernet-mac-and-10base-t-phy/]
  . [http://www.fpga4fun.com/10BASE-T.html]
  . [http://midir.fi/?i=ktvwn44y&la=en]

and some publicity available code (small state machines) on interfacing with a PHY device. Our targeting PHY interface *DP83848J* might be used in this way, so check out:

  . [http://forums.xilinx.com/t5/Spartan-Family-FPGAs/UDP-IP-stack-on-a-Spartan-6/td-p/149492]
  . [http://www.joelw.id.au/FPGA/DigilentAtlysResources]
  . [http://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/f2011/mis47_ayg6/mis47_ayg6/]
  . [https://www.deyisupport.com/question_answer/dsp_arm/sitara_arm/f/25/t/45981.aspx] In Chinese

An GMAC on opencore.org (I do not like opencores as I had little success in using that website)

  . [http://opencores.org/project,ethernet_tri_mode]

Some discussions indicated that, it may not be a wise choice to use FPGA to negotiate with the ethernet protocol, the best choice is a microcontroller.

  . [http://www.eevblog.com/forum/microcontrollers/open-(functional!)-core-for-ethernet-vhdl-for-ethernet-spartan-6/?PHPSESSID=f6f35063e39f50fd4818c8ba811cac6f Topic: Open (functional!) core for Ethernet / VHDL for Ethernet - Spartan 6?  (Read 3120 times)]

as I only had a spartan6 FPGA, a softcore (lattice8 or lattice32, Microblaze) is my third (last) choice.

If crafting an PHY \+ MAC \+ IP protocol is not your *job*, then simply using one softcore with light IP stack.


